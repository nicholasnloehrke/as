#!/usr/bin/env python3

import argparse
from parser import Parser
import sys

opcode_map = {
    "add": 0b0000,
    "sub": 0b0001,
    "slt": 0b0010,
    "li": 0b0011,
    "lw": 0b0100,
    "sw": 0b0101,
    "beq": 0b0110,
    "bne": 0b0111,
    "push": 0b1000,
    "pop": 0b1001,
    "j": 0b1010,
    "jal": 0b1011,
    "jr": 0b1100,
    "nop": 0b1101,
}


def regnum(r):
    return int(r[1])


def encode_instruction(instr):
    op = instr[0]
    opcode = opcode_map.get(op)
    if opcode is None:
        raise ValueError(f"Unknown opcode: {op}")

    if op == "li":
        dsel = regnum(instr[1])
        imm = instr[2] & 0b11111
        return (opcode << 7) | (dsel << 5) | imm

    elif op in ("add", "sub", "slt"):
        dsel = regnum(instr[1])
        r1 = regnum(instr[2])
        r2 = regnum(instr[3])
        operand = (r1 << 2) | r2
        return (opcode << 7) | (dsel << 5) | operand

    elif op in ("lw", "sw", "push", "pop"):
        dsel = regnum(instr[1])
        addr = instr[2] if len(instr) > 2 else 0
        return (opcode << 7) | (dsel << 5) | (addr & 0b11111)

    elif op in ("beq", "bne"):
        dsel = regnum(instr[1])
        addr = instr[2] & 0b11111
        return (opcode << 7) | (dsel << 5) | addr

    elif op in ("j", "jal"):
        addr = instr[1] & 0b11111
        return (opcode << 7) | (0 << 5) | addr

    elif op == "jr":
        return opcode << 7

    elif op == "nop":
        return opcode << 7

    else:
        raise ValueError(f"Unhandled instruction: {instr}")


def to_mif(instructions, outfile=None):
    if len(instructions) > 32:
        RED = "\033[31m"
        BOLD = "\033[1m"
        RESET = "\033[0m"

        print(
            f"{RED}{BOLD}{outfile + ': ' if outfile else ''}error: out of RAM. Used {len(instructions)} of 32 words{RESET}"
        )
        sys.exit(1)

    content = """-- Auto generated by https://github.com/nicholasnloehrke/as

WIDTH=11;
DEPTH=32;

ADDRESS_RADIX=UNS;
DATA_RADIX=BIN;

CONTENT BEGIN
"""
    for i, instr in enumerate(instructions):
        encoding = encode_instruction(instr)
        op = instr[0]
        comment = f"-- {op}{' ' * (4 - len(op))}"
        operands = instr[1:]

        if len(operands) >= 1:
            comment += f" {operands[0]}"
            for operand in operands[1:]:
                comment += f", {operand}"

        content += f"{i:02} : {encoding:011b}; {comment}\n"

    for j in range(i + 1, 32):
        content += f"{j:02} : 00000000000;\n"

    content += "END;"

    if outfile:
        with open(outfile, "w") as file:
            file.write(content)
    else:
        print(content)


def main():
    argparser = argparse.ArgumentParser()
    argparser.add_argument("infile", help="Input file")
    argparser.add_argument("-o", help="Output file")
    args = argparser.parse_args()

    with open(args.infile) as f:
        code = f.read()

    parser = Parser()
    parsed = parser.parse(code, file_name=args.infile)

    to_mif(parsed, args.o)


if __name__ == "__main__":
    main()
